from __future__ import annotations

import random
from pathlib import Path
from textwrap import dedent
from typing import Tuple

from Bio.Seq import Seq  # type: ignore
from Bio.SeqRecord import SeqRecord  # type: ignore
from Bio import SeqIO  # type: ignore

from .utils import LOGGER, ensure_dir, set_seed


def fasta_to_pdb(sequence: str, out_dir: str | Path) -> Path:
    """Konvertiere eine Peptidsequenz in eine Dummy-PDB-Datei.

    In Produktionsumgebungen würde hier ColabFold/ESMFold aufgerufen.
    Für die CI erzeugen wir deterministische Zufallskoordinaten, damit die
    Downstream-Pipeline agieren kann, ohne die externen Modelle zu benötigen.
    """
    set_seed()
    out_dir = ensure_dir(out_dir)
    pdb_path = Path(out_dir) / "model_dummy.pdb"

    # Aminosäure-Mapping von Einzelbuchstaben zu vollständigen Namen
    aa_mapping = {
        'A': 'ALA', 'R': 'ARG', 'N': 'ASN', 'D': 'ASP', 'C': 'CYS',
        'E': 'GLU', 'Q': 'GLN', 'G': 'GLY', 'H': 'HIS', 'I': 'ILE',
        'L': 'LEU', 'K': 'LYS', 'M': 'MET', 'F': 'PHE', 'P': 'PRO',
        'S': 'SER', 'T': 'THR', 'W': 'TRP', 'Y': 'TYR', 'V': 'VAL'
    }
    
    # Schreibe vollständige PDB-Datei mit allen Atomen
    lines: list[str] = []
    lines.append("REMARK  Generated by amp-rbc-md")
    lines.append("TITLE     Peptide Structure")
    
    atom_idx = 1
    for res_idx, aa in enumerate(sequence, start=1):
        # Vollständiger Aminosäure-Name
        aa_full = aa_mapping.get(aa, aa)
        
        # Basis-Position für das Residuum
        base_x = random.uniform(-1, 1) * 0.5 * res_idx
        base_y = random.uniform(-1, 1) * 0.5 * res_idx
        base_z = random.uniform(-1, 1) * 0.5 * res_idx
        
        # Standard-Atome für jedes Aminosäure
        atoms = [
            ("N", 0.0, 0.0, 0.0),
            ("CA", 1.5, 0.0, 0.0),
            ("C", 2.5, 0.0, 0.0),
            ("O", 3.0, 0.0, 0.0),
        ]
        
        # Sidechain-Atome je nach Aminosäure
        if aa in "FYW":
            atoms.append(("CB", 1.0, 1.5, 0.0))
        elif aa in "DEKRH":
            atoms.append(("CB", 1.0, 1.5, 0.0))
        elif aa in "STNQ":
            atoms.append(("CB", 1.0, 1.5, 0.0))
        elif aa in "ACGPILMV":
            atoms.append(("CB", 1.0, 1.5, 0.0))
        
        for atom_name, dx, dy, dz in atoms:
            x = base_x + dx
            y = base_y + dy
            z = base_z + dz
            lines.append(
                "ATOM  {idx:5d}  {atom:>2s}  {aa:>3s} A{res:4d}    "
                "{x:8.3f}{y:8.3f}{z:8.3f}  1.00  0.00           C".format(
                    idx=atom_idx,
                    atom=atom_name,
                    aa=aa_full,
                    res=res_idx,
                    x=x,
                    y=y,
                    z=z,
                )
            )
            atom_idx += 1
    
    lines.append("TER")
    lines.append("END")
    pdb_path.write_text("\n".join(lines))

    # Speichere FASTA parallel, nützlich für Referenz.
    fasta_path = Path(out_dir) / "sequence.fasta"
    SeqIO.write(
        SeqRecord(Seq(sequence), id="peptide", description=""), fasta_path, "fasta"
    )

    LOGGER.info("Dummy-PDB unter %s erzeugt", pdb_path)
    return pdb_path


__all__ = ["fasta_to_pdb"]
